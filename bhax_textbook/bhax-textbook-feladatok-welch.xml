<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Welch!</title>
    </info>

    <section>
        <title>Első osztályom</title>
        <para>
            Valósítsd meg C++-ban és Java-ban a módosított polártranszformációs algoritmust! A matek háttér 
            teljesen irreleváns, csak annyiban érdekes, hogy az algoritmus egy számítása során két normálist
            számol ki, az egyiket elspájzolod és egy további logikai taggal az osztályban jelzed, hogy van vagy
            nincs eltéve kiszámolt szám.
        </para>
        <para>
            Megoldás forrása: a második előadás <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/UDPROG-BHAX/Prog1_5.pdf">17-22 fólia</link>.
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... térj ki arra is, hogy a JDK forrásaiban a Sun programozói
            pont úgy csinálták meg ahogyan te is, azaz az OO nemhogy nem nehéz, hanem éppen természetes neked!
        </para>
        <para>
        Először nézzük meg, hogy nézne ki osztályok nélkül a feladat: (C-ben)
        </para>
        <programlisting language="c">
<![CDATA[
double rand_polar()
{
    static double stored;
    static bool hasStored = false;

    if(hasStored)
    {
        hasStored = false;
        return stored;
    }

    double v1, v2, w;

    do
    {
        v1 = (double)rand() / RAND_MAX * 2.0 - 1;
        v2 = (double)rand() / RAND_MAX * 2.0 - 1;
        w = v1 * v1 + v2 * v2;
    } while(w > 1);

    double r = sqrt(-2.0 * log(w) / w);

    hasStored = true;
    stored = r * v2;

    return r * v1;
}
]]>
        </programlisting>
        <para>
        Ez a megoldás azt a kevés állapotot, amit meg kell tartanunk, statikus változókban tárolja. Ehhez képest
        egy objektum-orientált megközelítésben ezt az állapotot egy osztályba foglaljuk: (C++)
        </para>
        <programlisting language="c++">
<![CDATA[class polargen
{
public:
    polargen() = default;

    double next() { /*...*/ }

private:
    double stored;
    bool hasStored;
} ]]>
        </programlisting>
    <para>
    Ennek a nem statikus megközelítésnek akkor van igazán értelme, ha pszeudo-random értékeket akarunk generálni,
    példányokhoz kötött <code>seed</code> alapján. Ehhez C++-ban ezesetben ajánlatos az
    <code>std::uniform_real_distribution</code> osztályt használni egy <code>std::default_random_engine</code> 
    generátorral: (összetettebb, mint a <code>rand()</code>, de több lehetőséget nyújt)
    </para>
    <programlisting language="c++">
<![CDATA[class polargen
{
public:
    polargen()
      : rdev(
            std::chrono::system_clock
               ::now().time_since_epoch().count()
        ),
        r_unif_dist(-1.0, 1.0),
        hasStored(false) {}

    polargen(uint_fast32_t seed)
      : rdev(seed),
        r_unif_dist(-1.0, 1.0),
        hasStored(false) {}

    double next()
    {
        /*...*/

        //Véletlen számok genrálása a -1.0 és 1.0 közötti értékekre beállított std::uniform_real_distribution-nel:
            v1 = r_unif_dist(rdev);
            v2 = r_unif_dist(rdev);
        
        /*...*/
    }

private:
    std::default_random_engine rdev;
    std::uniform_real_distribution<double> r_unif_dist;
    double stored;
    bool hasStored;
}]]>
        </programlisting>
        <para>***</para>
        <para>
        Javában hasonló módon járunk el, viszont itt bele vagyunk kényszerítve
        egy objektum-orientált keretbe (ez a Java egy gyakran kritizált tulajdonsága).
        </para><para>
        Kétféle implementáció lehetséges: létrehozhatunk egy statikus osztályt
        (privát konstuktor, csak statikus elemek) <code>java.lang.Math.random()</code>-mal,
        vagy készíthetünk egy példányosítható osztályt, amely <code>java.util.Random</code>-ot használ.
        Az utóbbi esetében példányonként megadhatunk egy seedet.
        </para>
        <para>Itt a seedelhető változat:
        (valójában redundáns, mivel lényegében ugyanazt éri el, mint a <code>Random.nextGaussian()</code>)</para>
<programlisting language="java">
<![CDATA[package prog1.welch;

import java.util.Random;

public class polar {
    Random rand;
    boolean hasStoredValue;
    double storedValue;

    public polar() {
        rand = new Random();
        hasStoredValue = false;
    }

    public polar(long seed) {
        rand = new Random(seed);
        hasStoredValue = false;
    }

    double next() {
        if(hasStoredValue) {
            hasStoredValue = false;
            return storedValue;
        }

        double v1, v2, w;

        do {
            v1 = rand.nextDouble() * 2 - 1;
            v2 = rand.nextDouble() * 2 - 1;
            w = v1 * v1 + v2 * v2;
        } while(w > 1);

        double r = Math.sqrt(-2.0 * Math.log(w) / w);

        hasStoredValue = true;
        storedValue = r * v2;

        return r * v1;
    }
}]]>
</programlisting>
        <para><quote>
        "...térj ki arra is, hogy a JDK forrásaiban a Sun programozói
            pont úgy csinálták meg ahogyan te is, azaz az OO nemhogy nem nehéz, hanem éppen természetes neked!"
        </quote></para>
        <para>Ez majdnem igaz, annyi kiegészítéssel, hogy az előbb említett <code>java.util.Random</code> osztály
        thread-safe, azaz több szálon is használható. (Nem ajánlatos egy <code>Random</code> példányt több szál között
        megosztva használni, de mindenesetre lehetséges.)</para>
    </section>

    <section>
        <title>LZW</title>
        <para>
            Valósítsd meg C-ben az LZW algoritmus fa-építését!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat">https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat</link>.
        </para>
        <para>
        Ehhez először hozzunk létre egy bináris fa csomópont struktúrát:
        </para>
        <programlisting language="c"><![CDATA[
typedef struct tag_bintree_node
{
    int data;
    struct tag_bintree_node* left;
    struct tag_bintree_node* right;
} bintree_node;
        ]]></programlisting>
        <para>Ezt felhasználva csináljunk egy fejléc jellegű LZW fa struktúrát:</para>
        <programlisting language="c"><![CDATA[
typedef struct
{
    bintree_node *root;
    int n_nodes;
    bintree_node *ins;
} lzw_hdr;]]>
        </programlisting>
        <para>Írjunk pár függvényt hozzá:</para>
        <programlisting language="c"><![CDATA[
lzw_hdr lzw_create(void)
{
    lzw_hdr tree;
    tree.root = calloc(1, sizeof(bintree_node));
    tree.n_nodes = 1;
    tree.ins = tree.root;
    return tree;
}

void lzw_insert(lzw_hdr *tree, char ch)
{
    if(tree->root == NULL || tree->ins == NULL) return;

    bintree_node **child = NULL;

    if(ch == '0') child = &tree->ins->left;
    else if(ch =='1') child = &tree->ins->right;
    else return;
    
    if(*child == NULL)
    {
        *child = calloc(1, sizeof(bintree_node));
        //(*child)->data = tree->n_nodes++;
        (*child)->data = ch == '0' ? 0 : 1;

        tree->ins = tree->root;
    }
    else tree->ins = *child;
}

void lzw_free(lzw_hdr *tree)
{
    bintree_free(tree->root);
    tree->root = tree->ins = NULL;
    tree->n_nodes = 0;
}

void bintree_free(bintree_node *root)
{
    if(root->left != NULL)
        bintree_free(root->left);
    if(root->right != NULL)
        bintree_free(root->right);
    free(root);
}]]>
        </programlisting>
        <para>És készen is van minden, amire szükségünk van LZW-fák létrehozásához. Egy egyszerű <code>main()</code>,
        hogy ki is tudjuk próbálni: (A <code>bintree_print()</code> implementációjához lásd a teljes forrást)</para>
        <programlisting language="c"><![CDATA[
int main()
{
    srand(1);
    setlocale(LC_ALL, "");

    lzw_hdr tree = lzw_create();

    char input;
    while(!feof(stdin))
    {
        input = (char)getchar();
        if(input != '0' && input != '1') continue;

        lzw_insert(&tree, input);
    }

    bintree_print(tree.root, 0);

    lzw_free(&tree);

    return 0;
}]]>
        </programlisting>
        <para>Futtassuk le a programot, adjunk neki bemenetet:</para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="img/6-2-term.png"/>
            </imageobject>
        </mediaobject>
    </section>

    <section>
        <title>Fabejárás</title>
        <para>
            Járd be az előző (inorder bejárású) fát pre- és posztorder is!
        </para>
        <para>
            Megoldás forrása:
        </para>
        <para>Rekuzió használatával néha kifejezetten nehéz problémákra is tudunk egyszerű megoldásokat találni.
        Az előző feladatban létrehozott bináris fa bejárása is lényegében négy rekurzív lépésben bejárható:</para>
        <itemizedlist>
        <listitem><para>megnézzük, hogy a gyökér csomópont <code>NULL</code> érték-e, ha igen, visszatérünk</para></listitem>
        <listitem><para>feldolgozzuk a csomópontot (ezesetben kiírjuk)</para></listitem>
        <listitem><para>bejárjuk a bal oldali részfát</para></listitem>
        <listitem><para>bejárjuk a jobb oldali részfát</para></listitem>
        </itemizedlist>
        <para>Az utolsó három lépés sorrendje alapján kapunk preorder, inorder, vagy postorder bejárást.
        Ezek így néznek ki C-ben:</para>
        <programlisting language="c">
<![CDATA[void bintree_preorder_print(bintree_node *root)
{
    if(root == NULL) return;
    printf("%d", root->data);
    bintree_preorder_print(root->left);
    bintree_preorder_print(root->right);
}

void bintree_inorder_print(bintree_node *root)
{
    if(root == NULL) return;
    bintree_preorder_print(root->left);
    printf("%d", root->data);
    bintree_preorder_print(root->right);
}

void bintree_postorder_print(bintree_node *root)
{
    if(root == NULL) return;
    bintree_postorder_print(root->left);
    bintree_postorder_print(root->right);
    printf("%d", root->data);
}]]>
        </programlisting>
    <para>Ha a bejárás során tovább akarunk adni valamilyen adatot, például az eddigi lépések számát
    (a tényleges gyökértől való távolság), ezt megtehetjük egy plusz paraméter segítségével. Mivel C-ben
    nem adhatunk egy függvény paramétereinek alapértelmezett értéket, így a könnyebb használat érdekében
    két függvényt érdemes írnunk. Itt a preorder bejárás "továbbfejlesztett" változata:</para>
    <programlisting><![CDATA[
void bintree_preorder_print_d(bintree_node *root)
{
    _bintree_preorder_print_d(root, 0);
}

void _bintree_preorder_print_d(bintree_node *root, int depth)
{
    if(root == NULL) return;
    for(int i = 0; i < depth; i++) printf(" "); 
    printf("%d\n", root->data);
    _bintree_preorder_print_d(root->left, depth + 1);
    _bintree_preorder_print_d(root->right, depth + 1);
}
]]></programlisting>
    <para>
    Az teljes forráskódban fellelhető <code>bintree_print()</code> függvény is tulajdonképpen ennek felel meg,
    annyi különbséggel, hogy szóközök helyett egy kevés extra logika alapján és egy pár Unicode karakter felhasználásával
    egy fa szerkezetet rajzol ki.
    </para>
    </section>

    <section>
        <title>Tag a gyökér</title>
        <para>
            Az LZW algoritmust ültesd át egy C++ osztályba, legyen egy Tree és egy beágyazott Node
            osztálya. A gyökér csomópont legyen kompozícióban a fával!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/_mu54BDkqiQ">https://youtu.be/_mu54BDkqiQ</link>
        </para>
        <para>
            Megoldás forrása: ugyanott.
        </para>
    </section>

    <section>
        <title>Mutató a gyökér</title>
        <para>
            Írd át az előző forrást, hogy a gyökér csomópont ne kompozícióban, csak aggregációban legyen a 
            fával!
        </para>
       <para>
            Megoldás videó: <link xlink:href="https://youtu.be/_mu54BDkqiQ">https://youtu.be/_mu54BDkqiQ</link>
        </para>
        <para>
            Megoldás forrása: ugyanott.
        </para>
        <para>
        Ez a feladat a kompozícióhoz képest annyiban tér el, hogy a
        </para>
        <programlisting language="c++">node root;</programlisting>
        <para>helyett</para>
        <programlisting language="c++">node *root;</programlisting>
        <para>fog szerepelni a <code>bin_tree&lt;&gt;</code> osztályban, illetve a konstruktorokban és a destruktorban
        <code>new</code> és <code>delete</code> utasításokra van szükségünk:</para>
        <programlisting language="c++">
bin_tree() : root(new node()) {}
bin_tree(const T&amp; r) : root(new node(r)) {}
~bin_tree() { delete root; }
        </programlisting>
        <para>Használhatunk ehelyett <code>std::unique_ptr&lt;node&gt;</code>-t is a birtoklás erősebb kifejezésére,
        ekkor külön <code>delete</code>-re sincs szükségünk.</para>
        <para>
        </para>
     </section>

    <section>
        <title>Mozgató szemantika</title>
        <para>
            Írj az előző programhoz másoló/mozgató konstruktort és értékadást, a mozgató konstruktor legyen a mozgató
            értékadásra alapozva, a másoló értékadás pedig a másoló konstruktorra!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/QBD3zh5OJ0Y">https://youtu.be/QBD3zh5OJ0Y</link>
        </para>
        <para>
            Megoldás forrása: ugyanott.
        </para>
        <para>
        Késztetést érzek rá, hogy a feladattól eltérjek, mivel a mozgató konstruktort a mozgató értékadásra alapozni
        elég szokatlan és előnytelen dolog (másolásnál is). Általában pont fordítva szokott lenni: a konstruktornak
        egyszerűbb a feladata, csak fel kell építenie egy példányt adott másolandó/mozgatandó példány alapján. Az
        értékadó operátoroknak viszont emellett meg is kell semmisíteniük az előző érték mögött álló példányt.
        </para>
    </section>

    <section>
        <title>Vörös Pipacs Pokol/5x5x5 ObservationFromGrid</title>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/RedFlowerHell">https://github.com/nbatfai/RedFlowerHell</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... ezt kell az olvasónak kidolgoznia, mint labor- vagy otthoni mérési feladatot!
            Ha mi már megtettük, akkor használd azt, dolgozd fel, javítsd, adj hozzá értéket!
        </para>
    </section>
</chapter>
