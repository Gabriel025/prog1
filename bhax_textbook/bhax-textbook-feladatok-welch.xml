<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Welch!</title>
    </info>

    <section>
        <title>Első osztályom</title>
        <para>
            Valósítsd meg C++-ban és Java-ban a módosított polártranszformációs algoritmust! A matek háttér 
            teljesen irreleváns, csak annyiban érdekes, hogy az algoritmus egy számítása során két normálist
            számol ki, az egyiket elspájzolod és egy további logikai taggal az osztályban jelzed, hogy van vagy
            nincs eltéve kiszámolt szám.
        </para>
        <para>
            Megoldás forrása: a második előadás <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/UDPROG-BHAX/Prog1_5.pdf">17-22 fólia</link>.
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... térj ki arra is, hogy a JDK forrásaiban a Sun programozói
            pont úgy csinálták meg ahogyan te is, azaz az OO nemhogy nem nehéz, hanem éppen természetes neked!
        </para>
    </section>

    <section>
        <title>LZW</title>
        <para>
            Valósítsd meg C-ben az LZW algoritmus fa-építését!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat">https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat</link>.
        </para>
    </section>

    <section>
        <title>Fabejárás</title>
        <para>
            Járd be az előző (inorder bejárású) fát pre- és posztorder is!
        </para>
        <para>
            Megoldás forrása:
        </para>
        <programlisting language="c++">
        </programlisting>
    </section>

    <section>
        <title>Tag a gyökér</title>
        <para>
            Az LZW algoritmust ültesd át egy C++ osztályba, legyen egy Tree és egy beágyazott Node
            osztálya. A gyökér csomópont legyen kompozícióban a fával!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/_mu54BDkqiQ">https://youtu.be/_mu54BDkqiQ</link>
        </para>
        <para>
            Megoldás forrása: ugyanott.
        </para>
    </section>

    <section>
        <title>Mutató a gyökér</title>
        <para>
            Írd át az előző forrást, hogy a gyökér csomópont ne kompozícióban, csak aggregációban legyen a 
            fával!
        </para>
       <para>
            Megoldás videó: <link xlink:href="https://youtu.be/_mu54BDkqiQ">https://youtu.be/_mu54BDkqiQ</link>
        </para>
        <para>
            Megoldás forrása: ugyanott.
        </para>
        <para>
        Ez a feladat a kompozícióhoz képest annyiban tér el, hogy a
        </para>
        <programlisting language="c++">node root;</programlisting>
        <para>helyett</para>
        <programlisting language="c++">node *root;</programlisting>
        <para>fog szerepelni a <code>bin_tree&lt;&gt;</code> osztályban, illetve a konstruktorokban és a destruktorban
        <code>new</code> és <code>delete</code> utasításokra van szükségünk:</para>
        <programlisting language="c++">
        bin_tree() : root(new node()) {}
        bin_tree(const T&amp; r) : root(new node(r)) {}
        ~bin_tree() { delete root; }
        </programlisting>
        <para>Használhatunk ehelyett <code>std::unique_ptr&lt;node&gt;</code>-t is a birtoklás erősebb kifejezésére,
        ekkor külön <code>delete</code>-re sincs szükségünk.</para>
        <para>
        </para>
     </section>

    <section>
        <title>Mozgató szemantika</title>
        <para>
            Írj az előző programhoz másoló/mozgató konstruktort és értékadást, a mozgató konstruktor legyen a mozgató
            értékadásra alapozva, a másoló értékadás pedig a másoló konstruktorra!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/QBD3zh5OJ0Y">https://youtu.be/QBD3zh5OJ0Y</link>
        </para>
        <para>
            Megoldás forrása: ugyanott.
        </para>
        <para>
        Késztetést érzek rá, hogy a feladattól eltérjek, mivel a mozgató konstruktort a mozgató értékadásra alapozni
        elég szokatlan és előnytelen dolog (másolásnál is). Általában pont fordítva szokott lenni: a konstruktornak
        egyszerűbb a feladata, csak fel kell építenie egy példányt adott másolandó/mozgatandó példány alapján. Az
        értékadó operátoroknak viszont emellett meg is kell semmisíteniük az előző érték mögött álló példányt.
        </para>
    </section>

    <section>
        <title>Vörös Pipacs Pokol/5x5x5 ObservationFromGrid</title>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/RedFlowerHell">https://github.com/nbatfai/RedFlowerHell</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... ezt kell az olvasónak kidolgoznia, mint labor- vagy otthoni mérési feladatot!
            Ha mi már megtettük, akkor használd azt, dolgozd fel, javítsd, adj hozzá értéket!
        </para>
    </section>
</chapter>
