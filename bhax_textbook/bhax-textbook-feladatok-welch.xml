<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Welch!</title>
    </info>

    <section>
        <title>Első osztályom</title>
        <para>
            Valósítsd meg C++-ban és Java-ban a módosított polártranszformációs algoritmust! A matek háttér 
            teljesen irreleváns, csak annyiban érdekes, hogy az algoritmus egy számítása során két normálist
            számol ki, az egyiket elspájzolod és egy további logikai taggal az osztályban jelzed, hogy van vagy
            nincs eltéve kiszámolt szám.
        </para>
        <para>
            Megoldás forrása: a második előadás <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/UDPROG-BHAX/Prog1_5.pdf">17-22 fólia</link>.
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... térj ki arra is, hogy a JDK forrásaiban a Sun programozói
            pont úgy csinálták meg ahogyan te is, azaz az OO nemhogy nem nehéz, hanem éppen természetes neked!
        </para>
        <para>
        Először nézzük meg, hogy nézne ki osztályok nélkül a feladat: (C-ben)
        </para>
        <programlisting language="c">
<![CDATA[
double rand_polar()
{
    static double stored;
    static bool hasStored = false;

    if(hasStored)
    {
        hasStored = false;
        return stored;
    }

    double v1, v2, w;

    do
    {
        v1 = (double)rand() / RAND_MAX * 2.0 - 1;
        v2 = (double)rand() / RAND_MAX * 2.0 - 1;
        w = v1 * v1 + v2 * v2;
    } while(w > 1);

    double r = sqrt(-2.0 * log(w) / w);

    hasStored = true;
    stored = r * v2;

    return r * v1;
}
]]>
        </programlisting>
        <para>
        Ez a megoldás azt a kevés állapotot, amit meg kell tartanunk, statikus változókban tárolja. Ehhez képest
        egy objektum-orientált megközelítésben ezt az állapotot egy osztályba foglaljuk: (C++)
        </para>
        <programlisting language="c++">
<![CDATA[class polargen
{
public:
    polargen() = default;

    double next() { /*...*/ }

private:
    double stored;
    bool hasStored;
} ]]>
        </programlisting>
    <para>
    Ennek a nem statikus megközelítésnek akkor van igazán értelme, ha pszeudo-random értékeket akarunk generálni,
    példányokhoz kötött <code>seed</code> alapján. Ehhez C++-ban ezesetben ajánlatos az
    <code>std::uniform_real_distribution</code> osztályt használni egy <code>std::default_random_engine</code> 
    generátorral: (összetettebb, mint a <code>rand()</code>, de több lehetőséget nyújt)
    </para>
    <programlisting language="c++">
<![CDATA[class polargen
{
public:
    polargen()
      : rdev(
            std::chrono::system_clock
               ::now().time_since_epoch().count()
        ),
        r_unif_dist(-1.0, 1.0),
        hasStored(false) {}

    polargen(uint_fast32_t seed)
      : rdev(seed),
        r_unif_dist(-1.0, 1.0),
        hasStored(false) {}

    double next()
    {
        /*...*/

        //Véletlen számok genrálása a -1.0 és 1.0 közötti értékekre beállított std::uniform_real_distribution-nel:
            v1 = r_unif_dist(rdev);
            v2 = r_unif_dist(rdev);
        
        /*...*/
    }

private:
    std::default_random_engine rdev;
    std::uniform_real_distribution<double> r_unif_dist;
    double stored;
    bool hasStored;
}]]>
        </programlisting>
        <para>***</para>
        <para>
        Javában hasonló módon járunk el, viszont itt bele vagyunk kényszerítve
        egy objektum-orientált keretbe (ez a Java egy gyakran kritizált tulajdonsága).
        </para><para>
        Kétféle implementáció lehetséges: létrehozhatunk egy statikus osztályt
        (privát konstuktor, csak statikus elemek) <code>java.lang.Math.random()</code>-mal,
        vagy készíthetünk egy példányosítható osztályt, amely <code>java.util.Random</code>-ot használ.
        Az utóbbi esetében példányonként megadhatunk egy seedet.
        </para>
        <para>Itt a seedelhető változat:
        (valójában redundáns, mivel lényegében ugyanazt éri el, mint a <code>Random.nextGaussian()</code>)</para>
<programlisting language="java">
<![CDATA[package prog1.welch;

import java.util.Random;

public class polar {
    Random rand;
    boolean hasStoredValue;
    double storedValue;

    public polar() {
        rand = new Random();
        hasStoredValue = false;
    }

    public polar(long seed) {
        rand = new Random(seed);
        hasStoredValue = false;
    }

    double next() {
        if(hasStoredValue) {
            hasStoredValue = false;
            return storedValue;
        }

        double v1, v2, w;

        do {
            v1 = rand.nextDouble() * 2 - 1;
            v2 = rand.nextDouble() * 2 - 1;
            w = v1 * v1 + v2 * v2;
        } while(w > 1);

        double r = Math.sqrt(-2.0 * Math.log(w) / w);

        hasStoredValue = true;
        storedValue = r * v2;

        return r * v1;
    }
}]]>
</programlisting>
        <para><quote>
        "...térj ki arra is, hogy a JDK forrásaiban a Sun programozói
            pont úgy csinálták meg ahogyan te is, azaz az OO nemhogy nem nehéz, hanem éppen természetes neked!"
        </quote></para>
        <para>Ez majdnem igaz, annyi kiegészítéssel, hogy az előbb említett <code>java.util.Random</code> osztály
        thread-safe, azaz több szálon is használható. (Nem ajánlatos egy <code>Random</code> példányt több szál között
        megosztva használni, de mindenesetre lehetséges.)</para>
    </section>

    <section>
        <title>LZW</title>
        <para>
            Valósítsd meg C-ben az LZW algoritmus fa-építését!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat">https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat</link>.
        </para>
    </section>

    <section>
        <title>Fabejárás</title>
        <para>
            Járd be az előző (inorder bejárású) fát pre- és posztorder is!
        </para>
        <para>
            Megoldás forrása:
        </para>
        <programlisting language="c++">
        </programlisting>
    </section>

    <section>
        <title>Tag a gyökér</title>
        <para>
            Az LZW algoritmust ültesd át egy C++ osztályba, legyen egy Tree és egy beágyazott Node
            osztálya. A gyökér csomópont legyen kompozícióban a fával!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/_mu54BDkqiQ">https://youtu.be/_mu54BDkqiQ</link>
        </para>
        <para>
            Megoldás forrása: ugyanott.
        </para>
    </section>

    <section>
        <title>Mutató a gyökér</title>
        <para>
            Írd át az előző forrást, hogy a gyökér csomópont ne kompozícióban, csak aggregációban legyen a 
            fával!
        </para>
       <para>
            Megoldás videó: <link xlink:href="https://youtu.be/_mu54BDkqiQ">https://youtu.be/_mu54BDkqiQ</link>
        </para>
        <para>
            Megoldás forrása: ugyanott.
        </para>
        <para>
        Ez a feladat a kompozícióhoz képest annyiban tér el, hogy a
        </para>
        <programlisting language="c++">node root;</programlisting>
        <para>helyett</para>
        <programlisting language="c++">node *root;</programlisting>
        <para>fog szerepelni a <code>bin_tree&lt;&gt;</code> osztályban, illetve a konstruktorokban és a destruktorban
        <code>new</code> és <code>delete</code> utasításokra van szükségünk:</para>
        <programlisting language="c++">
        bin_tree() : root(new node()) {}
        bin_tree(const T&amp; r) : root(new node(r)) {}
        ~bin_tree() { delete root; }
        </programlisting>
        <para>Használhatunk ehelyett <code>std::unique_ptr&lt;node&gt;</code>-t is a birtoklás erősebb kifejezésére,
        ekkor külön <code>delete</code>-re sincs szükségünk.</para>
        <para>
        </para>
     </section>

    <section>
        <title>Mozgató szemantika</title>
        <para>
            Írj az előző programhoz másoló/mozgató konstruktort és értékadást, a mozgató konstruktor legyen a mozgató
            értékadásra alapozva, a másoló értékadás pedig a másoló konstruktorra!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/QBD3zh5OJ0Y">https://youtu.be/QBD3zh5OJ0Y</link>
        </para>
        <para>
            Megoldás forrása: ugyanott.
        </para>
        <para>
        Késztetést érzek rá, hogy a feladattól eltérjek, mivel a mozgató konstruktort a mozgató értékadásra alapozni
        elég szokatlan és előnytelen dolog (másolásnál is). Általában pont fordítva szokott lenni: a konstruktornak
        egyszerűbb a feladata, csak fel kell építenie egy példányt adott másolandó/mozgatandó példány alapján. Az
        értékadó operátoroknak viszont emellett meg is kell semmisíteniük az előző érték mögött álló példányt.
        </para>
    </section>

    <section>
        <title>Vörös Pipacs Pokol/5x5x5 ObservationFromGrid</title>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/RedFlowerHell">https://github.com/nbatfai/RedFlowerHell</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... ezt kell az olvasónak kidolgoznia, mint labor- vagy otthoni mérési feladatot!
            Ha mi már megtettük, akkor használd azt, dolgozd fel, javítsd, adj hozzá értéket!
        </para>
    </section>
</chapter>
